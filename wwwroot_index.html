<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>MCP Swagger Proxy UI</title>
    <link rel="icon" type="image/svg+xml" href="/slimfaas.svg" />
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 2em; }
        .tool { margin-bottom: 2em; border: 1px solid #ccc; padding: 1em; }
        .file-input { display: block; margin: 6px 0; }
    </style>
</head>
<body>
<h2>MCP Swagger Proxy Web UI</h2>
<label>Swagger URL:
    <input id="swaggerUrl" type="text" value="https://petstore3.swagger.io/api/v3/openapi.json" style="width: 50%;" />
</label>
<br>
<label>Base URL override:
    <input id="baseUrl" type="text" placeholder="(optional, e.g. https://petstore3.swagger.io/api/v3)" value="https://petstore3.swagger.io/api/v3" style="width: 50%;" />
</label><br>
<label>Tool prefix:
    <input id="toolPrefix" type="text" placeholder="(optional, e.g. myapp)" style="width: 50%;" />
</label><br>
<label style="display:block;margin-top:8px;">
    <input id="structuredContentCheckbox" type="checkbox">
    Activer <code>structured_content</code> (inclure <code>structuredContent</code> dans la réponse)
</label><br>
<label>MCP Prompt base 64:
    <input id="mcpPromptbase64input" type="text" placeholder="(optional)" style="width: 50%;" />
</label>
<button onclick="loadTools()">Load Tools</button>
<hr>
<h3>📝 MCP Prompt (YAML)</h3>
<textarea id="mcpPrompt" rows="10" style="width:80%;" placeholder="Colle ici ton MCP Prompt YAML"></textarea>
<div style="margin-top: 6px;">
    <b>Base64 encodé :</b>
    <textarea readonly id="mcpPromptBase64" style="font-family:monospace;background:#eef;padding:2px 8px;"></textarea>
</div>
<hr>
<h3>🔒 OAuth 2.0 Protected Resource Metadata</h3>
<textarea id="oauthMeta" rows="10" style="width:80%;">
{
  "resource": "https://api.example.com/v1/",
  "authorization_servers": ["https://auth.example.com"],
  "scopes_supported": ["read:data", "write:data"]
}
</textarea>
<div style="margin-top:6px;">
    <b>Base64 encodé :</b>
    <textarea id="oauthMetaBase64" readonly style="font-family:monospace;background:#eef;padding:2px 8px;"></textarea>
</div>
<div id="shareUrlContainer" style="margin-top:8px;max-width: 100%;word-break: break-word;">
    <b>URL MCP :</b>
    <span id="shareUrl" style="font-family:monospace;"></span>
</div>
<div id="oauthShareUrlContainer"
     style="margin-top:4px;max-width:100%;word-break:break-word;">
    <b>URL OAuth MCP :</b>
    <span id="oauthShareUrl" style="font-family:monospace;"></span>
</div>
<button onclick="applyMcpPrompt()">Appliquer le MCP Prompt</button>

<hr>
<label>Access token :
    <input id="accessToken"
           type="text"
           placeholder="(optional Bearer token)"
           style="width:50%;" />
</label><br>


<hr>
<div id="tools"></div>

<script>
    function getBearerHeader() {
        const token = document.getElementById("accessToken").value.trim();
        return token ? { "Authorization": `Bearer ${token}` } : {};
    }
    function isStructuredContentEnabled() {
        const el = document.getElementById("structuredContentCheckbox");
        return !!(el && el.checked);
    }
    function isBase64(str) {
        return /^[A-Za-z0-9+/]+={0,2}$/.test(str || "");
    }

    let loadedTools  = [];
    let mergedTools  = [];
    let mcpPromptJson = null;

    function encodeOAuthMeta() {
        const txt = document.getElementById("oauthMeta").value.trim();
        if (!txt) {
            document.getElementById("oauthMetaBase64").textContent = "";
            return "";
        }
        try {
            const b64 = btoa(unescape(encodeURIComponent(txt)));
            document.getElementById("oauthMetaBase64").textContent = b64;
            return b64;
        } catch(e) {
            document.getElementById("oauthMetaBase64").textContent = `# Erreur : ${e.message}`;
            return "";
        }
    }

    document.getElementById("oauthMeta").addEventListener("input", () => {
        encodeOAuthMeta();
        updateShareUrl();
    });

    function updateShareUrl() {
        const swagger   = document.getElementById("swaggerUrl").value.trim();
        const base      = document.getElementById("baseUrl").value.trim();
        const oauthB64  = document.getElementById("oauthMetaBase64").textContent.trim();
        const mcpB64    = document.getElementById("mcpPromptBase64").textContent.trim();
        const toolPrefix = document.getElementById("toolPrefix").value.trim();
        const structured = isStructuredContentEnabled();

        const originPath = window.location.origin +
            window.location.pathname.replace(/\/$/, "");

        let url = `${originPath}/mcp?openapi_url=${encodeURIComponent(swagger)}`;
        if (base) url += `&base_url=${encodeURIComponent(base)}`;
        if (isBase64(mcpB64) && mcpB64)   url += `&mcp_prompt=${encodeURIComponent(mcpB64)}`;
        if (isBase64(oauthB64) && oauthB64) url += `&oauth=${encodeURIComponent(oauthB64)}`;
        if (structured)         url += `&structured_content=true`;
        if (toolPrefix) url += `&tool_prefix=${encodeURIComponent(toolPrefix)}`;

        const span = document.getElementById("shareUrl");
        span.textContent = url;
        if (url.length > 8000) {
            span.style.color = "red";
            span.title = `⚠️ ${url.length} caractères – URL trop longue (max 8000)`;
        } else {
            span.style.color = "green";
            span.title = "";
        }

        const pathMeta = oauthB64
            ? `/${oauthB64}/.well-known/oauth-protected-resource`
            : "/.well-known/oauth-protected-resource";
        const metaUrl  = `${originPath}${pathMeta}`;
        document.getElementById("oauthShareUrl").textContent = metaUrl;
    }

    ["swaggerUrl", "baseUrl", "toolPrefix"].forEach(id => {
        document.getElementById(id).addEventListener("input", () => updateShareUrl());
    });

    function buildMinimalMcpPrompt({ loadedTools, uiTools }) {
        const prompt      = {};
        const origMap     = new Map(loadedTools.map(t => [t.name, t]));
        const activeTools = uiTools.filter(t => !t.isDisabled).map(t => t.name);
        if (activeTools.length !== loadedTools.length) prompt.activeTools = activeTools;

        const modified = [];
        for (const t of uiTools) {
            const orig = origMap.get(t.name);
            if (!orig) {
                modified.push({ name: t.name, description: t.description, inputSchema: t.inputSchema });
                continue;
            }
            const descChanged   = t.description !== orig.description;
            const schemaChanged = JSON.stringify(t.inputSchema) !== JSON.stringify(orig.inputSchema);
            if (descChanged || schemaChanged) {
                const delta = { name: t.name };
                if (descChanged)   delta.description = t.description;
                if (schemaChanged) delta.inputSchema = t.inputSchema;
                modified.push(delta);
            }
        }
        if (modified.length) prompt.tools = modified;
        return prompt;
    }

    function toYamlBase64(obj) {
        const yaml = window.jsyaml.dump(obj);
        const b64  = btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
        return { yaml, b64 };
    }

    function getMcpPromptBase64() {
        const promptObj = buildMinimalMcpPrompt({
            loadedTools,
            uiTools: mergedTools.length ? mergedTools : loadedTools
        });
        const { yaml, b64 } = toYamlBase64(promptObj);
        document.getElementById("mcpPromptBase64").textContent = b64;
        updateShareUrl();
        return { yaml, b64 };
    }

    document.getElementById("mcpPrompt").addEventListener("input", getMcpPromptBase64);

    async function loadTools() {
        const swaggerUrl = document.getElementById("swaggerUrl").value.trim();
        const baseUrl    = document.getElementById("baseUrl").value.trim();
        const b64Prompt  = document.getElementById("mcpPromptbase64input").value.trim();
        const toolPrefix = document.getElementById("toolPrefix").value.trim();

        let endpoint = `/tools?openapi_url=${encodeURIComponent(swaggerUrl)}`;
        if (baseUrl) endpoint += `&base_url=${encodeURIComponent(baseUrl)}`;
        const oauthB64 = encodeOAuthMeta();
        if (oauthB64) endpoint += `&oauth=${encodeURIComponent(oauthB64)}`;
        if (isStructuredContentEnabled()) endpoint += `&structured_content=true`;
        if (toolPrefix) endpoint += `&tool_prefix=${encodeURIComponent(toolPrefix)}`;
        let headers = getBearerHeader();

        const toolsRes = await fetch(endpoint, { method: "GET", headers });
        const tools    = await toolsRes.json();
        loadedTools    = tools;

        let yaml;
        if (b64Prompt) {
            try {
                const jsonStr = decodeURIComponent(escape(window.atob(b64Prompt)));
                yaml = window.jsyaml.dump(JSON.parse(jsonStr));
            } catch (e) {
                yaml = `# Erreur décodage base64 : ${e.message}`;
            }
        } else {
            yaml = window.jsyaml.dump({
                activeTools: tools.map(t => t.name),
                tools: tools.map(t => ({
                    name: t.name,
                    description: t.description,
                    inputSchema: t.inputSchema,
                    outputSchema: t.outputSchema
                }))
            });
        }
        document.getElementById("mcpPrompt").value = yaml;
        getMcpPromptBase64();
        renderTools();
    }

    function needsFile(val) {
        return (val && (val.format === "binary"
            || (val.properties && val.properties.data && val.properties.data.contentEncoding === "base64")));
    }

    function buildToolForm(tool) {
        const formDiv = document.getElementById(`inputForm_${tool.name}`);
        formDiv.innerHTML = "";
        const contentType = tool.endpoint?.contentType || "application/json";
        const props       = tool.inputSchema?.properties || {};

        if (contentType === "multipart/form-data" || contentType === "application/octet-stream") {
            for (const [key, val] of Object.entries(props)) {
                if (needsFile(val)) {
                    formDiv.innerHTML += `<label>${key} (file): <input class="file-input" type="file" id="${tool.name}_input_${key}"></label><br>`;
                } else {
                    formDiv.innerHTML += `<label>${key}: <input class="file-input" type="text" id="${tool.name}_input_${key}"></label><br>`;
                }
            }
        } else {
            formDiv.innerHTML += `<textarea id="${tool.name}_input_json" rows="4" placeholder='JSON input'></textarea>`;
        }
    }

    function readFileAsBase64(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const s = String(reader.result || "");
                const idx = s.indexOf("base64,");
                resolve(idx >= 0 ? s.substring(idx + 7) : s);
            };
            reader.onerror = e => reject(e);
            reader.readAsDataURL(file);
        });
    }

    async function runTool(name) {
        const tool     = loadedTools.find(t => t.name === name);
        const swagger  = document.getElementById("swaggerUrl").value.trim();
        const baseUrl  = document.getElementById("baseUrl").value.trim();
        const toolPrefix = document.getElementById("toolPrefix").value.trim();

        let endpoint   = `/tools/${name}?openapi_url=${encodeURIComponent(swagger)}`;
        if (baseUrl) endpoint += `&base_url=${encodeURIComponent(baseUrl)}`;
        const { b64 }  = getMcpPromptBase64();
        if (b64) endpoint += `&mcp_prompt=${encodeURIComponent(b64)}`;
        const oauthB64 = document.getElementById("oauthMetaBase64").textContent.trim();
        if (isBase64(oauthB64) && oauthB64) endpoint += `&oauth=${encodeURIComponent(oauthB64)}`;
        if (isStructuredContentEnabled()) endpoint += `&structured_content=true`;
        if (toolPrefix) endpoint += `&tool_prefix=${encodeURIComponent(toolPrefix)}`;

        const contentType = tool.endpoint?.contentType || "application/json";
        let body;
        let headers = getBearerHeader();

        if (contentType === "multipart/form-data" || contentType === "application/octet-stream") {
            // ✅ Envoie JSON MCP avec binaires en base64
            const props = tool.inputSchema.properties || {};
            const args = {};
            for (const [key, val] of Object.entries(props)) {
                if (needsFile(val)) {
                    const fileInput = document.getElementById(`${tool.name}_input_${key}`);
                    if (fileInput.files.length) {
                        const file = fileInput.files[0];
                        const base64 = await readFileAsBase64(file);
                        args[key] = {
                            data: base64,
                            filename: file.name,
                            mimeType: file.type || "application/octet-stream"
                        };
                    }
                } else {
                    const txtInput = document.getElementById(`${tool.name}_input_${key}`);
                    if (txtInput.value) args[key] = txtInput.value;
                }
            }
            headers["Content-Type"] = "application/json";
            body = JSON.stringify(args);
        } else {
            headers["Content-Type"] = "application/json";
            const txt = document.getElementById(`${tool.name}_input_json`).value || "{}";
            body = JSON.stringify(JSON.parse(txt));
        }

        try {
            const res  = await fetch(endpoint, { method: "POST", headers, body });
            const text = await res.text();
            let data;
            try { data = JSON.parse(text); } catch { data = text; }
            document.getElementById("output_" + name).innerText = typeof data === "string" ? data : JSON.stringify(data, null, 2);
        } catch (e) {
            document.getElementById("output_" + name).innerText = e.message;
        }
    }

    function renderTools(isMerge = false) {
        const container = document.getElementById("tools");
        container.innerHTML = "";
        const tools = isMerge ? mergedTools : loadedTools;
        for (const tool of tools) {
            let bg = "white", label = "";
            if (tool.isAdded)      { bg = "#d2ffd2"; label = "🆕 Tool ajouté"; }
            else if (tool.isDisabled) { bg = "#ffd6d6"; label = "⛔ Tool désactivé"; }
            else if (tool.isOverridden) { bg = "#f4fff0"; label = "✅ Tool surchargé"; }

            const descStyle   = tool.isDescriptionOverridden ? "color:green;font-weight:bold;" : "";
            const schemaStyle = tool.isInputSchemaOverridden ? "background:#c2ffcf;" : "";

            const scEnabled = isStructuredContentEnabled();
            const outputSchemaBlock = scEnabled
                ? `<h4>Output schema</h4>
     <pre>${window.jsyaml.dump(tool.outputSchema)}</pre>`
                : `<h4>Output schema</h4>
     <pre>(hidden — enable structured_content)</pre>`;

            container.innerHTML += `
<div class="tool" style="background:${bg};">
  <h4>${tool.name} ${label ? `<span style="font-size:0.8em;color:#333;margin-left:8px;">${label}</span>` : ""}</h4>
  <div><b style="${descStyle}">${tool.description}</b></div>
  <h4>Input schema</h4>
  <pre style="${schemaStyle}">${window.jsyaml.dump(tool.inputSchema)}</pre>
  ${outputSchemaBlock}
  ${tool.isDisabled ? '<i>Tool désactivé</i>' : `
    <div id="inputForm_${tool.name}"></div>
    <button onclick="runTool('${tool.name}')">Run</button>
    <div id="output_${tool.name}" style="background:#eee;margin-top:1em;"></div>
  `}
  <div style="font-size:small;margin-top:6px;"><b>Content-Type:</b> ${tool.endpoint?.contentType || "application/json"}</div>
</div>`;
            if (!tool.isDisabled) buildToolForm(tool);
        }
    }

    function applyMcpPrompt() {
        const yamlStr = document.getElementById("mcpPrompt").value;
        let prompt;
        try {
            prompt = window.jsyaml.load(yamlStr) || {};
        } catch (e) {
            alert("Erreur YAML : " + e.message);
            return;
        }
        mcpPromptJson = prompt;

        const activeSet = prompt.activeTools ? new Set(prompt.activeTools) : null;
        mergedTools = [];
        const originMap = new Map(loadedTools.map(t => [t.name, t]));

        for (const orig of loadedTools) {
            const override = (prompt.tools || []).find(t => t.name === orig.name);
            const active   = activeSet ? activeSet.has(orig.name) : true;
            mergedTools.push({
                ...orig,
                description: override?.description || orig.description,
                inputSchema: override?.inputSchema || orig.inputSchema,
                isOverridden:           !!override,
                isDescriptionOverridden:!!(override && override.description),
                isInputSchemaOverridden:!!(override && override.inputSchema),
                isDisabled:             !active,
                isAdded:                false,
            });
        }

        if (prompt.tools) {
            for (const t of prompt.tools) {
                if (!originMap.has(t.name)) {
                    mergedTools.push({
                        ...t,
                        isOverridden: false,
                        isDescriptionOverridden: !!t.description,
                        isInputSchemaOverridden: !!t.inputSchema,
                        isDisabled: false,
                        isAdded: true,
                        inputSchema: t.inputSchema || {},
                        description: t.description || "(Tool ajouté par YAML)",
                        endpoint: { contentType: "application/json" },
                    });
                }
            }
        }

        renderTools(true);
        getMcpPromptBase64();
    }

    // Synchronise la checkbox avec l'URL si quelqu'un colle ?structured_content=true
    (function initStructuredContentFromUrl() {
        const cb = document.getElementById("structuredContentCheckbox");
        const params = new URLSearchParams(window.location.search);
        const enabled = params.get("structured_content") === "true";
        if (cb) cb.checked = enabled;
    })();

    // Recalcule l'URL de partage quand on (dé)coche
    document.getElementById("structuredContentCheckbox")
        .addEventListener("change", updateShareUrl);

    encodeOAuthMeta();
    updateShareUrl();
</script>
</body>
</html>
